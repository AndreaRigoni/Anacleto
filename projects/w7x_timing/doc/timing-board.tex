% Some macros for logic timing diagrams.
%
% Author: ir. Pascal T. Wolkotte and Jochem Rutgers, University of Twente
\documentclass{article}
\usepackage{verbatim,calc,listings,lscape}
\usepackage[margin=1cm]{geometry}
\begin{comment}
:Title: Timing diagram
:Tags: Diagrams, Macro packages

Uses ``timing.sty``, a convenient set of macros for drawing
logic timing diagrams. Written by Pascal Wolkotte and Jochem Rutgers.

The macros are also available as a separate sty file:

- `timing.sty`_

.. _timing.sty: /media/pgftikzexamples/circuits/timing.sty

:Authors: ir. Pascal T. Wolkotte and Jochem Rutgers, University of Twente


\end{comment}

% Start of timing.sty

% Some macros for logic timing diagrams.
%
% Author: ir. Pascal T. Wolkotte and Jochem Rutgers, University of Twente
% Version: 0.1
% Date: 2007/10/11
\usepackage{tikz}
\newcounter{wavenum}
\setlength{\unitlength}{1pt}
% advance clock one cycle, not to be called directly
\newcommand*{\clki}{
  \draw (t_cur) -- ++(0,.3) -- ++(.5,0) -- ++(0,-.6) -- ++(.5,0) -- ++(0,.3)
    node[time] (t_cur) {};
}
\newcommand*{\bitvector}[3]{
  \draw[fill=#3] (t_cur) -- ++( .1, .3) -- ++(#2-.2,0) -- ++(.1, -.3)
                         -- ++(-.1,-.3) -- ++(.2-#2,0) -- cycle;
  \path (t_cur) -- node[anchor=mid] {#1} ++(#2,0) node[time] (t_cur) {};
}
% \known{val}{length}
\newcommand*{\known}[2]{
    \bitvector{#1}{#2}{white}
}
% \unknown{length}
\newcommand*{\unknown}[2][]{
    \bitvector{#1}{#2}{black!20}
}
% \bit{1 or 0}{length}
\newcommand*{\bit}[2]{
  \draw (t_cur) -- ++(0,.6*#1-.3) -- ++(#2,0) -- ++(0,.3-.6*#1)
    node[time] (t_cur) {};
}
% \unknownbit{length}
\newcommand*{\unknownbit}[1]{
  \draw[ultra thick,black!20] (t_cur) -- ++(#1,0) node[time] (t_cur) {...};
}
% \nextwave{name}
\newcommand{\nextwave}[1]{
  \path (0,\value{wavenum}) node[left] {#1} node[time] (t_cur) {};
  \addtocounter{wavenum}{-1}
}
% \clk{name}{period}
\newcommand{\clk}[2]{
    \nextwave{#1}
    \FPeval{\res}{(\wavewidth+1)/#2}
    \FPeval{\reshalf}{#2/2}
    \foreach \t in {1,2,...,\res}{
        \bit{\reshalf}{1}
        \bit{\reshalf}{0}
    }
}
% \begin{wave}[clkname]{num_waves}{clock_cycles}
\newenvironment{wave}{
  \begin{tikzpicture}[draw=black, yscale=.7,xscale=.58]
    \tikzstyle{time}=[coordinate]
}{\end{tikzpicture}}
% \begin{wave}[clkname]{num_waves}{clock_cycles}
\newenvironment{wave2}[2][10MHz clk]{
  \begin{wave}
    \setcounter{wavenum}{0} 
		\nextwave{#1}
    \foreach \t in {-1,0,...,23}{
      \draw[dotted] (t_cur) +(0,.5) node[above] {\t} -- ++(0,.4-#2);
      \clki
    }
		\unknownbit{1}{1}
		\foreach \t in {88,89,...,101}{
      \draw[dotted] (t_cur) +(0,.5) node[above] {\t} -- ++(0,.4-3);
      \clki
    }
}{\end{wave}}
%%% End of timing.sty

\begin{document}
\thispagestyle{empty}
\part*{\center RedPitaya - Timing Module}
\section*{Firmware}
\subsection*{Data types}
Definition: \textit{boolean} = 1bit logical, \textit{int} = 4byte integer, \textit{long} = 8byte integer.\\
Using \textit{int} as data type for DELAY and SEQUENCE limits the maximal duration to little more than 3.5 minutes. Considering quasi continuous pulses, \textit{long} should be used.
\subsection*{private parameters - registers}
\begin{tabular}{llll}
address&name&type&description\\\hline
0x0000&INIT&boolean&Used to deinit() the device and break the loops in armed() and program().\\
0x0008&DELAY&long&Number of tick between the input trigger and the beginning of the first sequence.\\
0x0010&WIDTH&long&Number of ticks the output remains high when raised.\\
0x0018&PERIOD&long&Minimum number of ticks between two raising edges:\\
&&& 1. defines the rate of a pulse train.\\
&&& 2. defines when the gate closes after the last pulse.\\
0x0020&CYCLE&long&Number of ticks between two sequence starts (c.f. PERIOD but for the sequence).\\
0x0028&REPEAT&int&Number of sequence repetitions.\\
0x002C&COUNT&int&Number of pulses in a sequence or pulse train.\\
0x0030&SEQUENCE&long[]&Increasing number of tick counts since the sequence start to the raising edge of a pulse.\\
\end{tabular}
\subsubsection*{Startup states}
INIT is cleared, all parameters are set to 0/null, i.e. the whole register is cleared. However, it is satisfactory to ensure the clearing of the first 30 bytes. All outputs should be on low. Unused digital pins should be configured as input.
\subsection*{Network packages}
The body of init1() and init2() could be copied to the register directly as byte stream.

\begin{tabular}{l=l:l}
address&name&size&description\\\hline
0x0000&magic&3bytes&Magic bytes, e.g. $0x573758=$'W7X'\\
0x0003&method&1byte&Method identifier, i.e. deinit: 0x00, init1: 0x01, init2: 0x02\\
0x0004&length&4bytes&Length of argument body, i.e. deinit: 0, init2: 40, init1: 40 + 8 count\\
0x0008&delay&8bytes&1nd argument\\
0x0010&width&8bytes&2nd argument\\
0x0018&period&8bytes&3rd argument\\
0x0020&cycle&8bytes&4th argument\\
0x0028&repeat&4bytes&5th argument\\
0x002C&count&4bytes&7th argument\\
0x0030&sequence[0]&8bytes&1st element of sequence argument (only for init1)\\
...
\end{tabular}

\subsection*{Network interrupts (public methods)}
\subsubsection*{deinit (method = 0x00)}
INIT is cleared. This will interrupt the loops in armed() and program() if running. The device is idling until the next init.
\subsubsection*{init1 (method = 0x01)}
The parameters DELAY, WIDTH, PERIOD, CYCLE, REPEAT, COUNT, and SEQUENCE are transmitted. INIT is set. The device is armed().
\subsubsection*{init2 (method = 0x02)}
The parameters DELAY, WIDTH, PERIOD, CYCLE, REPEAT, and COUNT are transmitted. SEQUENCE is generated from PERIOD and COUNT. INIT is set. The device is armed().
\subsection*{private methods}
\subsubsection*{armed}
The procedure armed() calls getTrigger() until it returns TRUE, in which case armed() executes program(). The device will remain armed until a deinit interrupt.
\subsubsection*{program}
The method program() generates the trigger and gate signal. It is called by armed() when once trigger has occurred.
\subsubsection*{advance}
The method advance(T,G) synchronizes the code. If INIT is set the output channels are set to T and G. Otherwise, they are both cleared. It returns TRUE if INIT was not set.
\subsection*{abstract methods}
\subsubsection*{getTrigger}
The method getTrigger() checks the TRIGGER register and returns TRUE if the trigger level has been high.
\subsubsection*{setOutput}
The method setOutput(T,G) sets the state of trigger\_out and gate\_out to T and G, respectively.
\subsubsection*{sync}
The method sync() synchronizes the code to the with the external clock (raising/falling edge).

\subsection*{Timing}
The board cycle is synchronized to an external clock of $10$Mhz.
The most important aspect is that the jitter is minimized. Fixed delays of a few ticks ($<10$ maybe) are acceptable. The most important part is that the timestamps of the TTLs can be calculate with little uncertainty based on the external clock. The Input trigger is expected to be synchronized with the external clock (raising edge). Hence one could think of setting the output on the falling edge to achieve a fixed delay of only $50$ns.

\clearpage\thispagestyle{empty}
\subsection*{Program (example)}
\begin{lstlisting}
private const int InitException     = -1;
private const int PeriodException   = -3;
private const int CycleException    = -5;
private const int SequenceException = -7;
private boolean INIT;
private long CYCLE, DELAY, WIDTH, PERIOD, SEQUENCE[];
private int REPEAT, COUNT

public int init1(long delay, long width, long period, long cycle,
					int repeat, int count, long[] sequence){
	IF(INIT)
		return InitException;
	IF(period <= width)
		return PeriodException
	IF(cycle < sequence[count-1]+period)
		return CycleException
	for (int i = 1 ; i < count ; i++)
		if(sequence[i] < sequence[i-1]+period)  return SequenceException
	init(delay, width, period, cycle, repeat, count, sequence);
}

public int init2(long delay, long width, long period, long cycle, int repeat, int count){
	IF(INIT)
		return InitException;
	IF(period <= width)
		return PeriodException
	IF(cycle < count*period)
		return CycleException
	sequence = new long[count];
	for (long i = 0 ; i < count ; i++)
		sequence[i] = period*i;
	init(delay, width, period, cycle, repeat, count, sequence);
}

public void deinit(){
	INIT = 0;
}

private int init(long delay, long width, long period, long cycle,
					int repeat, int count, long[] sequence){
	INIT = 1;
	DELAY = delay;
	WIDTH = width;
	PERIOD = period;
	CYCLE = cycle;
	REPEAT = repeat;
	COUNT = count;
	SEQUENCE = sequence;//possibly copy
	setOutput(0,0);
	Thread.invoke(armed());
	return 1;
}
					
private void armed(){
	while(INIT){
		if(!getTrigger()) continue;
		program();
	}
}
\end{lstlisting}
\clearpage\thispagestyle{empty}
\subsection*{Program (continue)}
\begin{lstlisting}
private void program(){
	for(long t = 0 ; t < DELAY ;)
		if(advance(0,0)) return;
	for(int r = 0 ; r < REPEAT ; r++){
		long p, t = 0;
		for(int i = 0, ; i < COUNT ; i++){
			for (; t < SEQUENCE[i] ; t++)
				if(advance(0,1)) return;
			p = 0;
			for(; p < WIDTH ; p++, t++)
				if(advance(1,1)) return;
		}
		for(; p < PERIOD ; p++, t++)
			if(advance(0,1)) return;
		for(; t < CYCLE ; t++)
			if(advance(0,0)) return;
	}
}

private int advance(int T, int G){
	sync();
	if(INIT){
		setOutput(T,G);
		return 0;
	}
	setOutput(0,0);
	return 1;
}

private abstract int getTrigger();

private abstract void setOutput(int T, int G);

private abstract void sync();
\end{lstlisting}
\clearpage\thispagestyle{empty}
\begin{landscape}
\part*{\center Timing}
\section*{Program}
A program contains the list of strictly monotonic increasing tick counts relative to the trigger input for all pulses that will be generated when a trigger arrives. It is the lowest level of control. A program can be compiled as a initial $\mathrm{DELAY}$ and $\mathrm{REPEAT}$ identical, subsequent cycles.

\begin{wave}
 \nextwave{trigger\_in} \bit{0}{1}\bit{1}{1}\bit{0}{38}
\textbf{ \nextwave{program}\unknown{1}\known{program}{36}\unknown{3}
}
 \nextwave{delay}\unknown{1} \known{delay}{5}\unknown{34}
 \nextwave{N cycles}\unknown{6}\known{1st cycle}{10}\known{2nd cycle}{10}\unknownbit{1}\known{N-th cycle}{10}\unknown{3}
 \nextwave{sequence}\unknown{6}\known{1st sequence}{5}\unknown{5}\known{2nd sequence}{5}\unknown{5}\unknownbit{1}\known{N-th sequence}{5}\unknown{8}
\end{wave}

\section*{Cycle}
During every cycle a digital signal is generated. A gate signal will be high during the sequence and low during idle time. The duration of one cycle is defined by $\mathrm{CYCLE}$ and controls the repetition rate.
\subsection*{Sequence ($\mathrm{WIDTH}=2,\mathrm{PERIOD}=5,\mathrm{SEQUENCE}=\left[3,8,14,21,\cdots,92,96\right]$), init}
The digital signal is generated as a sequence of pulses of a given $\mathrm{WIDTH}$.
The timing of the pulses is defined by $\mathrm{SEQUENCE}$ that contains tick counts relative to the beginning of the cycle. The low-high transition of the gate is defined by the beginning of the cycle. The high-low transition is defined by the last element of $\mathrm{SEQUENCE}$ plus $\mathrm{PERIOD}$.


\begin{wave2}{3}
 \nextwave{signal}\bit{0}{4} \bit{1}{2} \bit{0}{3} \bit{1}{2} \bit{0}{4}\bit{1}{2}\bit{0}{5}\bit{1}{2}\bit{0}{1}\unknownbit{1}\bit{0}{4}\bit{1}{2}\bit{0}{2}\bit{1}{2}\bit{0}{4}
 \nextwave{gate}\bit{0}{1} \bit{1}{38}\bit{0}{1}
\end{wave2}

\subsection*{Pulse train ($\mathrm{WIDTH}=3,\mathrm{PERIOD}=10,\mathrm{COUNT}=10$), init2}
In pulse train mode the parameter $\mathrm{PERIOD}$ and $\mathrm{COUNT}$ are used generate a sequence of equidistant pulses.\hfill
$\mathrm{SEQUENCE} = [0:\mathrm{COUNT}-1]*\mathrm{PERIOD}$


\begin{wave2}{3}
 \nextwave{signal} \bit{0}{1}\bit{1}{3} \bit{0}{7} \bit{1}{3} \bit{0}{7}\bit{1}{3}\bit{0}{1}\unknownbit{1}\bit{0}{2}\bit{1}{3}\bit{0}{9}
 \nextwave{gate} \bit{0}{1}\bit{1}{37}\bit{0}{2}
\end{wave2}
\end{landscape}
\end{document}
